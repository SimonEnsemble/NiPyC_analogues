#! /usr/bin/env python

"""
Analyze MSD, and determine diffusion coefficients
"""

import numpy as np
import pylab as pl
import scipy.stats
import argparse
import sys


def PrintHelpText():
    """
    This function print the help-text, and then exits
    """

    print("""
This is help-text

If we give a list of input-files, the program will read them, and 
create merge them. 
""")

    sys.exit()




def MergeFiles(filelist):
    """
    Read a set of MSD-files, and calculate the average values, 
    we then then print the data to file, before we read it back 
    in again right away.
    """

    files = len(filelist)

    if files == 1:
        print("Working with one file. No point in doing all this extra work.")
        print("--merge can not be used with this")
        sys.exit()

    # load the first file, so we can check the sizes.
    data = np.loadtxt(filelist[0])
    rows = data.shape[0]
    cols = data.shape[1]

    container = np.zeros((rows,5,files))
    container[:,:,0] = data

    for i in range(1,len(filelist)):
        data = np.loadtxt(filelist[i])
        if data.shape[0] != rows:
            print("We have wrong number of rows in file %s" % filelist[i])
        
        if data.shape[1] != cols:
            print("We have wrong number of cols in file %s" % filelist[i])

        container[:,:,i] = data[:,:]

    data_avg = container.mean(axis=2) 
    data_std = container.std(axis=2)

    with open("tmp.msd","w") as f:
        for i in range(data_avg.shape[0]):
            f.write((5*"%10.5f   ") % (data_avg[i,0],data_avg[i,1],data_avg[i,2],data_avg[i,3],data_avg[i,4]))
            f.write((4*"%10.5f   ") % (data_std[i,1],data_std[i,2],data_std[i,3],data_std[i,4]))
            f.write("\n")

    outdata = np.zeros((rows,9))
    outdata[:,:5] = data_avg[:,:]
    outdata[:,5:] = data_std[:,1:]

    print("Created output-file 'tmp.msd'")



class MSD:
    def __init__(self,count,box=None,filename=None,data=None,decompose=False):
        
        self.count = count
        # we add the length of the box. the msd should be diffusive 
        # after box**2. after this length, if not, we might have a problem.
        # the system is not really explored
        if box!=None:
            self.box = float(box)
        else:
            self.box = None

        self.decompose=decompose

        self.scale_decomp = 1.0e-8/2.0 
        self.scale = 1.0e-8/6.0

        if filename!=None:
            data = np.loadtxt(filename)
        elif data == None:
            print("We have a system with no clear input.")
            sys.exit()
            
        self.ParseArgs(data)

        self.maxv = None
        self.minv = None

        self.linear_x_fit = None
        self.linear_y_fit = None
        self.linear_z_fit = None
        self.linear_fit = None
        
        self.log_x_fit = None
        self.log_y_fit = None
        self.log_z_fit = None
        self.log_fit = None




    def AddMM(self,minv,maxv):
        """
        Add a max and min val, used for interpolation.
        Also, find the index in the time-array that can be used for this.
        """

        if minv == "min":
            self.minv = self.time[0]
            self.min_ind = 0
        else:
            self.minv = minv
            if self.minv!=None:
                self.min_ind = np.argmax(self.time>minv)
            else:
                self.min_ind = None

        if maxv == "max":
            self.maxv = self.time[-1]
            self.max_ind = self.time.shape[0]
        else:

            self.maxv = maxv

            if self.maxv!=None:
                self.max_ind = np.argmax(self.time>maxv)
            else:
                self.max_ind = None
                


    def ParseArgs(self,data):
        """
        Parse the data
        """

        if data.shape[1] == 5:
            self.errorbar = False
            self.MSDx_std = None
            self.MSDy_std = None
            self.MSDz_std = None
            self.MSDavg_std = None
        elif data.shape[1] == 9:
            self.errorbar = True
            self.MSDx_std = data[:,5]
            self.MSDy_std = data[:,6]
            self.MSDz_std = data[:,7]
            self.MSDavg_std = data[:,8]
        else:
            print("We have an unknown number of cols.")
            print("We have this array dimentions: ", data.shape)

        self.time = data[:,0]
        self.MSDx = data[:,1]
        self.MSDy = data[:,2]
        self.MSDz = data[:,3]
        self.MSDavg = data[:,4]

        self.itime = 1.0/self.time
        self.iMSDx = self.MSDx/(2.0*self.time)
        self.iMSDy = self.MSDy/(2.0*self.time)
        self.iMSDz = self.MSDz/(2.0*self.time)
        self.iMSDavg = self.MSDavg / (6.0*self.time)

        if self.errorbar:
            self.iMSDavg_std =(self.MSDavg_std/(6.0*self.time))
            self.iMSDx_std = (self.MSDx_std/(2.0*self.time))
            self.iMSDy_std = (self.MSDy_std/(2.0*self.time))
            self.iMSDz_std = (self.MSDz_std/(2.0*self.time))
        else:
            self.iMSDavg_std = None
            self.iMSDx_std = None
            self.iMSDy_std = None
            self.iMSDz_std = None
        

        
    def ShowLinesLogLog(self,ax):
        """
        add lines to a log/log figure
        """

        ## add lines to the log-log figure
        tmax = self.time.max()
        tmin = self.time.min()

        t1 = np.logspace(np.log10(tmin),np.log10(tmax),200)
        t2 = np.logspace((0.0-(np.log10(tmax)-np.log10(tmin))),0,200)*self.MSDavg[-1]

        ax.plot(t1,t2,"-",color="red",lw=2)
        ax.plot(t1,t1**2,"-",color="black")



    def PlotOneDataset(self,atitle,data,data_err,idata,idata_err):
        """
        Plot one set of data.
        """

        fig1 = pl.figure(figsize=(8,8))
        fig2 = pl.figure(figsize=(8,8))
        fig3 = pl.figure(figsize=(8,8))

        # add a title in the figure
        #fig1.subtitle(atitle)


        # create exes 
        axlin = fig1.add_subplot(1,1,1)
        axlog = fig2.add_subplot(1,1,1)
        axinv = fig3.add_subplot(1,1,1)
        
        axlin.set_title(atitle+" Linear scale")
        axlog.set_title(atitle+" Logarithmic scale")
        axinv.set_title(atitle+" Inverse x-scale")

        # add the guiding axes in loglog plot
        self.ShowLinesLogLog(axlog)

        axlin.errorbar(self.time,data,yerr=data_err,fmt="-o",mfc='red',ms=6)
        axlog.errorbar(self.time,data,yerr=data_err, fmt="-o",mfc='red',ms=6)
        axinv.errorbar(self.itime,idata,yerr=idata_err,fmt="-o",mfc='red',ms=6)

        if self.maxv!=None:
            axlin.axvline(self.maxv)
            axlog.axvline(self.maxv)
            axinv.axvline(1.0/self.maxv)

        if self.minv!=None:
            axlin.axvline(self.minv)
            axlog.axvline(self.minv)
            axinv.axvline(1.0/self.minv)

        if (self.box !=None):
            axlin.axhline(self.box**2,ls="--",color="green")
            axlog.axhline(self.box**2,ls="--",color="green")
        
        axlin.set_xlabel("Time [ps]")
        axlin.set_ylabel("MSD [$\AA ^2$]")
        axlin.set_xscale("linear")
        axlin.set_yscale("linear")
        axlin.set_xlim((self.time[0]*0.9,self.time[-1]*1.1))

        axlog.set_xlabel("Time [ps]")
        axlog.set_ylabel("MSD [$\AA ^2$]")
        axlog.set_xscale("log")
        axlog.set_yscale("log")

        axinv.set_xlabel("1/Time [1/ps]")
        axinv.set_ylabel("MSD/(2d$\cdot$t) [$AA ^2/ps$]")
        axinv.set_xscale("log")
        axinv.set_yscale("linear")
        axlin.set_xlim((self.time[0]*0.9,self.time[-1]*1.1))

        
        # if we have defined a complete range, we can show this in an additional figure.
        # and add the lines that show the fit
        if self.minv != None and self.maxv!=None:

            fig4 = pl.figure(figsize=(12,6))
            axzoom = fig4.add_subplot(1,2,1)
            axzoomlog = fig4.add_subplot(1,2,2)

            if self.decompose:
                axzoom.plot(self.time[self.min_ind:self.max_ind],self.MSDx[self.min_ind:self.max_ind],"o-",label="")
                axzoom.plot(self.time[self.min_ind:self.max_ind],self.MSDy[self.min_ind:self.max_ind],"o-",label="")
                axzoom.plot(self.time[self.min_ind:self.max_ind],self.MSDz[self.min_ind:self.max_ind],"o-",label="")


            axzoom.plot(self.time[self.min_ind:self.max_ind],self.MSDavg[self.min_ind:self.max_ind],"o")

            lin_fit_range = np.linspace(self.minv,self.maxv,200)

            lin_data_fit = self.linear_fit[1] + self.linear_fit[0]*lin_fit_range
                
            axzoom.plot(lin_fit_range,lin_data_fit,"-")
        
            axzoom.set_xlabel("Time [ps]")
            axzoom.set_ylabel("MSD [$\AA ^2$]")
            axzoom.set_title(atitle + " Zoom on selected region")
            axzoom.set_xlim((self.minv*0.9,self.maxv*1.1))
        
        ## here we plot the data with the fitted line






    def PlotData(self):
        """
        Plot the MSD in x,y,and z-direction. These should 
        be the same if the system is isotropic.
        """


        if self.decompose:
            self.PlotOneDataset("MSD-x",self.MSDx,self.MSDx_std,self.iMSDx,self.iMSDx_std)
            self.PlotOneDataset("MSD-y",self.MSDy,self.MSDy_std,self.iMSDy,self.iMSDy_std)
            self.PlotOneDataset("MSD-z",self.MSDz,self.MSDz_std,self.iMSDz,self.iMSDz_std)
        else:
            self.PlotOneDataset("MSD-avg",self.MSDavg,self.MSDavg_std,self.iMSDavg,self.iMSDavg_std)

        pl.show()



    def LinearFit(self,time,msd):
        """
        Do linear regression on a dataset.

        First, we do regression on the data in linear space, then we do the same thing
        in log-space. In log-space, we should get a fit that is very close to 1.
        """
            
        linear_fit = scipy.stats.linregress(time,msd)
        log_fit = scipy.stats.linregress(np.log10(time),np.log10(msd))

        return linear_fit,log_fit


    def PrintData(self,lindata,logdata,name,scale):
        """
        Print the data to screen (in a nice way)
        """

        print(" Value for %s" % name)
        print("\t For fitting in the linear scope:")
        print("\t Curve had a linear slope of       %10.5f [AA^2/ps]" % lindata[0])
        ##print("\t giving a diffusion coeff of       %10.5f [m^2/s]" % (lindata[0]*self.scale))
        print("\t giving a diffusion coeff of       %g [m^2/s]" % (lindata[0]*scale))
        print("\t We intersect at                   %10.5f [AA^2]" % lindata[1])
        print("\t R-squared value: (1 is goal)      %10.5f " % lindata[2]**2)
        print("\t P-value: (should be small)        %10.5f " % lindata[3])
        print("\t S-value: (should be small)        %10.5f " % lindata[4])

        print("\n\t For fitting in the log scope:")
        print("\t Slope: (should be very close to 1)        %10.5f" % logdata[0])
        print("\t R-squared: (should be very close to 1)    %10.5f" % (logdata[2]**2))
        
        print("\t Data collected for diffusion over a timescale of %10.5f [ps]" % self.time[-1])





    def FindSlope(self): 
        """
        We find the slope of the data in the linear regime.
        """
        
        if self.minv==None or self.maxv==None:
            print("Cannot calculate slope. We have not specified range. ")
            print("Use --min NUMBER and --max NUMBER to specify linear ")
            print("--min min and --max max will specify the min and max values")
            print("(diffusive regime).")
            return


        time = self.time[self.min_ind:self.max_ind]

        # we print this data to screen right away if we find it. 
        print(72*"=")
        if self.decompose:
            print("Solving for MSD for {x,y,z}")
            linear_x_fit,log_x_fit = self.LinearFit(time,self.MSDx[self.min_ind:self.max_ind])
            linear_y_fit,log_y_fit = self.LinearFit(time,self.MSDy[self.min_ind:self.max_ind])
            linear_z_fit,log_z_fit = self.LinearFit(time,self.MSDz[self.min_ind:self.max_ind])

            #self.ShowResiduals(linear_x_fit,time,self.MSDx[self.min_ind:self.max_ind])

            self.PrintData(linear_x_fit,log_x_fit,"x-dir",self.scale_decomp)
            self.PrintData(linear_y_fit,log_y_fit,"y-dir",self.scale_decomp)
            self.PrintData(linear_z_fit,log_z_fit,"z-dir",self.scale_decomp)

            self.FindAverageDiffusion(linear_x_fix,linear_y_fit,linear_z_fit)


        print(72*"=")
        print("Solving for MSD for average")
        MSDdata = self.MSDavg[self.min_ind:self.max_ind]
        linear_fit,log_fit = self.LinearFit(time,MSDdata)
        self.linear_fit = linear_fit
        self.log_fit = log_fit
        self.ShowResiduals(linear_fit,time,MSDdata)
        self.PrintData(linear_fit,log_fit,"Average",self.scale)
        print(72*"=")
        

    def ShowResiduals(self,linear_fit,time,data):
        """
        Show the residuals on a linear and a log scale.
        """

        fig = pl.figure()
        axlin = fig.add_subplot(1,1,1)
        #axlog = fig.add_subplot(2,1,2)
        axlin.set_title("Residuals")

        residuals_lin = data - (linear_fit[1] + linear_fit[0]*time)
        #residulas_log = data - (

        axlin.plot(time,residuals_lin,"o")
        axlin.axhline(color="k")


    def FindAverageDiffusion(self,linearx,lineary,linearz):
        """
        Find the average diffusion coefficient. This should be more or
        less the same as we find using the mean msd-data to find it.
        Can be a nice test.
        """
            
        diff = ((linearx[0] + lineary[0] + linearz[0])*self.scale)/ 3.0 

        print("\n \t We found the average diffusion coefficient to be %10.5f [m^2/s]\n" % diff)






def main(args):
    """
    Here comes the main function
    """
    
    if(args.printh):
        PrintHelpText()
    
    if args.files == None:
        print("We have no input-files. No point to do anything.")
        return
    elif (len(args.files)>1):
        MergeFiles(args.files)
        return
    

    # parse max/min values.
    if(args.maxm!=None):
        if args.maxm == "max":
            maxval = "max"
        else: 
            maxval = float(args.maxm)
    else:
        maxval = None

    if(args.minm!=None):
        if args.minm== "min":
            minval = "min"
        else:
            minval = float(args.minm)
    else:
        minval = None

    msd = MSD(0,filename=args.files[0],box=args.box_side,decompose=args.decompose)
    msd.AddMM(minval,maxval)
    msd.FindSlope()

    if args.show:
        msd.PlotData()





if __name__ == "__main__":
    print("Analyzing MSD")

    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument("-f","--file",dest="files",nargs="+",help="Input-files")
    parser.add_argument("-s","--show",dest="show",action="store_false",help="Depress showing data.")
    parser.add_argument("--max",dest="maxm",type=str,default=None,help="Max value for extrapolation, max gives the highest value in dataset")
    parser.add_argument("--min",dest="minm",type=str,default=None,help="Mix value for extrapolation, min gives the smallest value in dataset")
    parser.add_argument("-l","--box",dest="box_side",help="Add the length of the box")
    parser.add_argument("-d","--decompose",dest="decompose",action="store_true",help="Show the MSD decomposed in x,y, and z-direction")
    parser.add_argument("-p","--print", dest="printh",action="store_true",help="Print help-text")

    args = parser.parse_args()
    print args
    main(args)
    print("Done")
